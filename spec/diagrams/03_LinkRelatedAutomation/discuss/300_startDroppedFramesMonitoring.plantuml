@startuml 300_startDroppedFramesMonitoring
skinparam responseMessageBelowArrow true

title
RequestForStartingDroppedFramesMonitoringCausesCyclicOperation
end title

participant "external" as requestor
participant "AIPS://v1/start-dropped-frames-monitoring" as startModule
participant "AIPS://v1/list-links-with-specific-automation-assigned" as listLinks
participant "MWDI://<get-dropped-frames>-todo" as mwdiDroppedFrames
participant "MWDI://v1/provide-list-of-parallel-links" as mwdiParallelLink
participant "AIPS://v1/provide-power-saving-status-of-link" as readStatus
participant "AIPS://v1/reactivate-transmitters-of-link" as reactivateTransmitters
participant "AIPS://v1/list-assignments-for-specific-link" as getAssignments
participant "AIPS://v1/remove-links-from-power-saving-activation-queue" as stopSimpleActivation
participant "AIPS://v1/add-links-to-power-saving-deactivation-queue" as startPersistentDeactivation

requestor -> startModule
activate startModule

'get all links subject to this automation
note over startModule
  <u>GetLinkIdList</u>
end note
startModule -> listLinks: {automationName="DroppedFramesInitiationRestoration"}
listLinks --> startModule: {linkIdList}

'monitor them constantly
group FOR each linkId from linkIdList
  note over startModule #lightBlue
    <u>GetDroppedFrames</u>
  end note
  startModule -> mwdiDroppedFrames: {linkId}
  mwdiDroppedFrames --> startModule: {response to-be-specified}
end

note over mwdiDroppedFrames #pink
  services to be determined,
  there might be multiple requests to MWDI required
  could possibly be realized as a service inside the
  link analysis module; there also the threshold could
  already be checked (service would just return true/false)
end note

group FOR each linkId from linkIdList
  'get parallel links
  note over startModule
    IF (droppedFramesRate > allowed threshold)
    THEN <u>GetParallelLinks</u>
  end note
  startModule -> mwdiParallelLink: {uuid=linkId}
  mwdiParallelLink --> startModule: {parallelLinksList}

  'if there are no parallel links
  note over startModule
    IF parallelLinksList.size() <= 1
    THEN CONTINUE with next linkId
  end note

  'there are parallel links, get their powerSavingStatus
  group FOR each parallelLinkId in parallelLinksList
    note over startModule
      <u>GetPowerSavingStatusOfLink</u>
    end note
    startModule -> readStatus: {parallelLinkId}
    readStatus --> startModule: {modulesToRestoreOriginalStateList}

    'continue with next parallel link if there is no powerSaving active
    note over startModule
      IF (modulesToRestoreOriginalStateList == emptyList)
      THEN CONTINUE with next parallel parallelLinkId
    end note

    group ELSE iterate over modulesToRestoreOriginalStateList
      'AllTransmitters on
      note over startModule
        IF (moduleName == "AllTransmittersOn")
        THEN <u>AllTransmittersOn</u>
      end note
      startModule -> reactivateTransmitters: {parallelLinkId, automationName="DroppedFramesInitiationRestoration"}

      note over startModule #lightBlue
        other module names can be added here later;
        they might require other actions than AllTransmittersOn
      end note
    end


    note over startModule, startPersistentDeactivation #pink
      Also remove entry for this parallel linkId from  SimpleActivationQueue and add to PersistentDeactivationQueue?

      for SimpleActivationQueue the correct automationName needs to be provided - retrieve assigned automationNames for the linkId
      and remove all entries

      for PersistendDeactivation the automationName could be droppedFrames to document that the droppedFrames module triggered the action...

      stellt sicher, dass das PowerSaving nicht direkt wieder aktiviert wird
      muss hier ggf. nicht gemacht werden
    end note

    'get automationNames for removal from SimpleActivationQueue
    note over startModule
      <u>GetAssignedAutomationNames</u>
    end note
    startModule -> getAssignments: {parallelLinkId}
    getAssignments -> startModule: {assignedAutomationNamesList}
    
    'remove the entries from SimpleActivationQueue
    group FOR each automationName in assignedAutomationNamesList
      note over startModule
        Remove all related entries in SimpleActivationQueue
        for the parallelLinkId
        <u>RemoveFrom<b>Activation</b>Queue</u>
      end note
      startModule -> stopSimpleActivation: {parallelLinkId, automationName}
      stopSimpleActivation --> startModule
    end

    'initiate restore, just in case the previously called action didn't work
    note over startModule
      Initiate restore in case the previously started restore did not work
      or if simpleActivation was already started again in the meantime
      <u>AddTo<b>Deactivation</b>Queue</u>
    end note
    startModule -> startPersistentDeactivation: {linkId, automationName="DroppedFramesInitiationRestoration", switchingOperationName="PersistentDeactivation"}
  end

end

deactivate startModule

@enduml